// Binary benchgen generates benchmarks based on directives found in test files.
package main

import (
	"bytes"
	"fmt"
	"go/ast"
	"go/parser"
	"go/printer"
	"go/token"
	"os"
	"strings"
)

func main() {
	if len(os.Args) != 2 {
		fatal("usage: [test_file]")
	}
	filename := os.Args[1]

	if !strings.HasSuffix(filename, "_test") {
		fatal(fmt.Sprintf("argument must be a valid _test.go file"))
	}

	fset, fileAst := parseFile(fmt.Sprintf("%s.go", filename))

	matrices := extractMatrix(fset, fileAst)
	targets := extractTargets(fset, fileAst, matrices)

	out, err := os.Create(fmt.Sprintf("%s_gen_test.go", strings.TrimSuffix(filename, "_test")))
	if err != nil {
		fatal(fmt.Sprintf("could not create file: %v", err))
	}
	defer out.Close()
	genTests(out, targets, matrices)
}

const template = `package pipelines_test

import "testing"

// This file was generated by pipelines_bench_gen.go. DO NOT EDIT!

`

func genTests(w *os.File, targets map[string]string, matrices map[string][]string) {
	w.WriteString(template)

	for funcName, matName := range targets {
		for i, arg := range matrices[matName] {
			testName := fmt.Sprintf("%s_%s_%d", strings.Title(funcName), matName, i)
			w.WriteString(fmt.Sprintf("func %s(b *testing.B) { %s(%s, b) }\n", testName, funcName, arg))
		}
	}
}

const BenchMatrixDir = "bench:matrix"
const BenchFuncDir = "bench:func"

// extractTargets extracts a map from function names to the matrix used to generate their calls.
func extractTargets(fset *token.FileSet, fileAst *ast.File, matrices map[string][]string) map[string]string {
	result := make(map[string]string)
	var errs []string
	for _, d := range fileAst.Decls {
		d, ok := d.(*ast.FuncDecl)
		if !ok {
			continue
		}
		tokens := parseDirective(d.Doc, BenchFuncDir)
		if tokens == nil {
			continue
		}
		if len(tokens) != 2 {
			errs = append(errs, err(fset, d, "bench:func directive takes a single argument"))
			continue
		}
		matrixName := tokens[1]
		if _, ok := matrices[matrixName]; !ok {
			errs = append(errs, err(fset, d, fmt.Sprintf("unknown matrix '%s' passed to bench:func directive", matrixName)))
		}
		result[d.Name.String()] = matrixName
	}
	if errs != nil {
		fatal(strings.Join(errs, "; "))
	}
	return result
}

// extractMatrix extracts a list of composite struct expressions to pass to each generated benchmark.
func extractMatrix(fset *token.FileSet, fileAst *ast.File) map[string][]string {
	result := make(map[string][]string)
	var errs []string
	for _, d := range fileAst.Decls {
		d, ok := d.(*ast.GenDecl)
		if !ok {
			continue
		}
		tokens := parseDirective(d.Doc, BenchMatrixDir)
		if tokens == nil {
			continue
		}
		if len(tokens) != 2 {
			errs = append(errs, err(fset, d, "bench:matrix directive takes a single argument"))
			continue
		}
		var b bytes.Buffer
		matrixName := tokens[1]
		for _, spec := range d.Specs {
			spec, ok := spec.(*ast.ValueSpec)
			if !ok {
				errs = append(errs, err(fset, d, "bench:matrix directive only allowed on var declarations"))
				continue
			}
			if len(spec.Values) != 1 {
				errs = append(errs, err(fset, spec, "bench:matrix directive requires single assignment"))
				continue
			}
			compLit, ok := spec.Values[0].(*ast.CompositeLit)
			if !ok {
				errs = append(errs, err(fset, compLit, "bench:matrix directive requires array of structs"))
			}
			arrType, ok := compLit.Type.(*ast.ArrayType)
			if !ok {
				errs = append(errs, err(fset, compLit, "bench:matrix directive requires array of structs"))
			}
			for _, elt := range compLit.Elts {
				eltCompLit, ok := elt.(*ast.CompositeLit)
				if !ok {
					errs = append(errs, err(fset, eltCompLit, "bench:matrix directive requires array of structs"))
				}
				eltCompLit.Type = arrType.Elt
				printer.Fprint(&b, fset, eltCompLit)
				result[matrixName] = append(result[matrixName], b.String())
				b.Reset()
			}
		}
	}
	if errs != nil {
		fatal(strings.Join(errs, "; "))
	}
	return result
}

func parseDirective(cg *ast.CommentGroup, key string) []string {
	if cg == nil {
		return nil
	}
	for _, c := range cg.List {
		trimmed := strings.TrimPrefix(c.Text, "//")
		if strings.HasPrefix(trimmed, key) {
			return strings.Split(trimmed, " ")
		}
	}
	return nil
}

func err(fset *token.FileSet, n ast.Node, err string) string {
	return fmt.Sprintf("%v: %s", fset.Position(n.Pos()), err)
}

// parseFile parses the test file to generate benchmarks for
func parseFile(filename string) (*token.FileSet, *ast.File) {
	fset := token.NewFileSet()
	astFile, err := parser.ParseFile(fset, filename, nil, parser.ParseComments)
	if err != nil {
		fatal(fmt.Sprintf("could not parse file %s", filename))
	}
	return fset, astFile
}

func fatal(msg string) {
	fmt.Fprintf(os.Stderr, msg)
	os.Exit(1)
}
